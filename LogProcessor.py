from os import error, write
import tkinter as tk
from tkinter import Tk     # from tkinter import Tk for Python 3.x
from tkinter import filedialog
import json
from tkinter import simpledialog
import tkinter
import numpy as np
import re
import random

badActorLabels = ('safe','ssh','ws','sql','ddos','ps','su')
root = Tk()

def Button():
    #errmsg = 'Error!'

    tk.Button(root, text='Organize Log File', 
        command=OrganizeLogsPrompt).pack(fill=tk.X)

    tk.Button(root, text='Create Universal Training & Testing Sets w/ Labels', 
        command=UniversalSetCreationPrompt).pack(fill=tk.X)
    
    tk.Button(root, text='Exit', 
        command=root.destroy).pack(fill=tk.X)

    root.mainloop()

def CloseProgram():
    root.destroy()

def OrganizeLogsPrompt():
    ans = tk.messagebox.askquestion(title="Are you sure?", message="This will overwrite any existing log" + 
        " files generated by a previous process. Do you want to continue?")
    if (ans == 'yes'):
        ans = 'no'
        while(ans == 'no'):
            filename = tk.filedialog.askopenfilename(title='Select Log File') # show an "Open" dialog box and return the path to the selected file
            ans = tk.messagebox.askquestion(title="Are you sure?", message="{}\n\nIs this the correct file?".format(filename))
        OrganizeLogs(filename)

def UniversalSetCreationPrompt(ans='a'):
    warning = check = None
    if (ans == 'a'):
        warning = tk.messagebox.askyesnocancel(title="Are you sure?", message="This will overwrite any existing sets" + 
            " generated by a previous process. Do you want to continue?")
    if (ans == 'a' and warning):
        check = tk.messagebox.askyesnocancel(title="Default Settings?", message="Universal Training Set Size: 1000\nUniversal Testing Set Size: 1000\nBad Actor Percentage: 25%" + 
            "\n\nDo you want to customize the settings?")
    if ((warning and check) or ans == 'no'):
        global promptInput

        promptInput = Tk()

        tk.Label(promptInput, text="Please enter desired size for the Universal Training Set").pack()
        trSetInput = tk.Entry(promptInput)
        trSetInput.pack()
        tk.Label(promptInput, text="Please enter desired size for the Universal Testing Set").pack()
        teSetInput = tk.Entry(promptInput)
        teSetInput.pack()
        tk.Label(promptInput, text="Please enter desired percentage of bad actors in the Universal Training Set").pack()
        percInput = tk.Entry(promptInput)
        percInput.pack()

        tk.Button(promptInput, text="Done", command=lambda:[UniversalSetCreationInput(trSetInput, teSetInput, percInput)]).pack()

        promptInput.mainloop()

    elif (warning != None and check != None):
        UniversalSetCreation()

def UniversalSetCreationInput(trSetInput, teSetInput, percInput):
    trainingSetSize = int(trSetInput.get())
    testingSetSize = int(teSetInput.get())
    badActorPerc = int(percInput.get())

    promptInput.destroy()

    ans = tk.messagebox.askquestion(title="Are you sure?", message="Universal Training Set Size: {}\nUniversal Testing Set Size: {}\nBad Actor Percentage: {}%\n\nIs this correct?"
        .format(trainingSetSize, testingSetSize, badActorPerc))
    if (ans =='no'):
        UniversalSetCreationPrompt(ans)
    UniversalSetCreation(trainingSetSize, testingSetSize, badActorPerc)

def OrganizeLogs(filename):

    with open(filename, 'r', encoding='utf8') as logs:
        errorLogs = open('errorLogs.txt', 'w', encoding='utf8')
        authLogs = open('authLogs.txt', 'w', encoding='utf8')
        accessLogs = open('accessLogs.txt', 'w', encoding='utf8')
        for line in logs:
            if re.search("^\[",line): #log starts with a square bracket, indicating this is an error.log log
                errorLogs.write(line)
            elif re.search("^\d",line): #log starts with a digit, indicating this is an access.log log used for malicious web server access bad actor
                accessLogs.write(line)
            elif re.search("^[A-Za-z]",line): #log starts with a alphabetical character, indicating this is an auth.log log
                authLogs.write(line)

        errorLogs.close()
        accessLogs.close()
        authLogs.close()

        with open('organizedLogs.txt', 'w', encoding='utf8') as organizedLogs:

            biLabels = []
            muLabels = []
            biIndex = 0
            muIndex = 0
            badActorBiLabels = [] 
            badActorMuLabels = []

            safeLogs = open('safeLogs.txt', 'w', encoding='utf8')
            sshLogs = open('sshlogs.txt', 'w', encoding='utf8')
            wsLogs = open('wsLogs.txt', 'w', encoding='utf8')
            sqlLogs = open('sqlLogs.txt', 'w', encoding='utf8')
            ddosLogs = open('ddosLogs.txt', 'w', encoding='utf8')
            psLogs = open('psLogs.txt', 'w', encoding='utf8')
            suLogs = open('sulogs.txt', 'w', encoding='utf8')
            badActorLogs = open('badActorLogs.txt', 'w', encoding='utf8')

            organizedLogs.write('error.log\n')
            with open('errorLogs.txt', 'r', encoding='utf8') as errorLogs:
                for line in errorLogs:
                    if 'AH01618' in line:
                        wsLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('ws'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    elif 'AH01617' in line:
                        sqlLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('sql'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    else:
                        safeLogs.write(line)
                        biLabels.append(0)
                        muLabels.append(badActorLabels.index('safe'))
                    organizedLogs.write(line)
            #organizedLogs.write(json.dumps(biLabels[biIndex: ]))
            #organizedLogs.write(json.dumps(muLabels[muIndex: ]))
            #organizedLogs.write('\n')
            #biIndex = len(biLabels)
            #muIndex = len(muLabels)

            organizedLogs.write('\nauth.log\n')
            with open('authLogs.txt', 'r', encoding='utf8') as authLogs:
                for line in authLogs:
                    if 'sshd[' in line and ('authentication failure' in line or 'maximum authentication attempts' in line):
                        sshLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('ssh'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    elif 'sshd[' in line and 'version differ' in line:
                        psLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('ps'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    elif 'sshd[' in line and 'no matching' in line:
                        psLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('ps'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    # 'sudo apt autoremove' and 'sudo apt-get autoremove' are flagged as a bad actor.
                    elif 'sudo' in line and 'remove' in line:
                        suLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('su'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    # Failed password attempts are flagged as bad actors
                    elif 'sudo' in line and 'incorrect password attempts' in line:
                        suLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('su'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    elif 'sudo' in line and 'authentication failure' in line:
                        suLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('su'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    else:
                        safeLogs.write(line)
                        biLabels.append(0)
                        muLabels.append(badActorLabels.index('safe'))
                    organizedLogs.write(line)
            #organizedLogs.write(json.dumps(biLabels[biIndex: ]))
            #organizedLogs.write(json.dumps(muLabels[muIndex: ]))
            #organizedLogs.write('\n')
            #biIndex = len(biLabels)
            #muIndex = len(muLabels)

            organizedLogs.write('\naccess.log\n')
            with open('accessLogs.txt', 'r', encoding='utf8') as accessLogs:
                for line in accessLogs:
                    if 'ApacheBench/2.3' in line:
                        ddosLogs.write(line)
                        badActorLogs.write(line)
                        biLabels.append(1)
                        muLabels.append(badActorLabels.index('ddos'))
                        badActorBiLabels.append(biLabels[-1])
                        badActorMuLabels.append(muLabels[-1])
                    else:
                        safeLogs.write(line)
                        biLabels.append(0)
                        muLabels.append(badActorLabels.index('safe'))
                    organizedLogs.write(line)
            #organizedLogs.write(json.dumps(biLabels[biIndex: ]))
            #organizedLogs.write(json.dumps(muLabels[muIndex: ]))
            #organizedLogs.write('\n')
            #biIndex = len(biLabels)
            #muIndex = len(muLabels)

            safeLogs.close()
            sshLogs.close()
            wsLogs.close()
            sqlLogs.close()
            ddosLogs.close()
            psLogs.close()
            suLogs.close()
            badActorLogs.close()

            with open('organizedLogs_Bi_labels.txt', 'w', encoding='utf8') as biLabelFile:
                json.dump(biLabels, biLabelFile)
            with open('organizedLogs_Mu_labels.txt', 'w', encoding='utf8') as muLabelFile:
                json.dump(badActorLabels, muLabelFile)
                json.dump(muLabels, muLabelFile)
            
            with open('badActors_Bi_labels.txt', 'w', encoding='utf8') as biLabelFile2:
                json.dump(badActorBiLabels, biLabelFile2)
            with open('badActors_Mu_labels.txt', 'w', encoding='utf8') as muLabelFile2:
                json.dump(badActorMuLabels, muLabelFile2)

def UniversalSetCreation(trainingSetSize=1000, testingSetSize=1000, badActorPerc=25):  
    trainingTotalLeft = trainingSetSize
    testingTotalLeft = testingSetSize

    universalTrainingSet = []
    universalTrainingBiLabels = []
    universalTrainingMuLabels = []

    universalTestingSet = []
    universalTestingBiLabels = []
    universalTestingMuLabels = []

    info = ''

    info += ('Expected Size of Universal Training Set: {}'.format(trainingSetSize)
        + '\nExpected Size of Universal Testing Set: {}'.format(testingSetSize) 
        + '\nNumber of Unique Bad Actors: {}'.format(len(badActorLabels[1:]))
        + '\nExpected Percentage of Bad Actors in Universal Training Set: {}%\n'.format(badActorPerc)
    )

    for filename in badActorLabels[1:]:
        badActorNum = 0

        with open('{}Logs.txt'.format(filename), 'r', encoding='utf8') as logs:
            lines = logs.readlines()
            random.shuffle(lines)
            badActorNum = min(len(lines),int((trainingSetSize*(badActorPerc/100))//(len(badActorLabels[1:]))))

            # Adding bad actors to training set
            for i in range(badActorNum):
                universalTrainingSet.append(lines[i])
                trainingTotalLeft -= 1
                universalTrainingBiLabels.append(1)
                universalTrainingMuLabels.append(badActorLabels.index(filename))

            # Adding bad actors to testing set
            if len(lines) > badActorNum:
                for i in range(min(len(lines)-badActorNum, badActorNum)):
                    universalTestingSet.append(lines[i + badActorNum])
                    testingTotalLeft -= 1
                    universalTestingBiLabels.append(1)
                    universalTestingMuLabels.append(badActorLabels.index(filename))

            info += '\nNumber of {} Bad Actor Logs added to Universal Training Set: {}'.format(filename, badActorNum)

    info += ( '\n\nNumber of Bad Actors in Universal Training Set: {}'.format(trainingSetSize - trainingTotalLeft)
        + '\nActual Percentage of Bad Actors in Universal Training Set: {}%\n'.format(round( ((trainingSetSize - trainingTotalLeft)/trainingSetSize)*100, 2) )
        + '\nNumber of Bad Actors in Universal Testing Set: {}'.format(testingSetSize - testingTotalLeft)
        + '\nActual Percentage of Bad Actors in Universal Testing Set: {}%\n'.format(round( ((testingSetSize - testingTotalLeft)/testingSetSize)*100, 2) )
    )

    sshSafeLimit = int((trainingSetSize*(1-(badActorPerc/100)))//( len(badActorLabels[1:] )))
    sshEveryOther = True
    with open('safeLogs.txt','r', encoding='utf8') as source:
        lines = source.readlines()
        random.shuffle(lines)
        for line in lines:
            if trainingTotalLeft > 0:
                if 'sshd[' in line and sshEveryOther and sshSafeLimit > 0:
                    universalTrainingSet.append(line)
                    sshEveryOther = not sshEveryOther
                    sshSafeLimit -= 1
                    universalTrainingBiLabels.append(0)
                    universalTrainingMuLabels.append(badActorLabels.index('safe'))
                    trainingTotalLeft -= 1
                elif 'sshd[' in line and not sshEveryOther and sshSafeLimit > 0:
                    sshEveryOther = not sshEveryOther
                else:
                    universalTrainingSet.append(line)
                    universalTrainingBiLabels.append(0)
                    universalTrainingMuLabels.append(badActorLabels.index('safe'))
                    trainingTotalLeft -= 1

            elif testingTotalLeft > 0:
                if 'sshd[' in line and sshEveryOther:
                    universalTestingSet.append(line)
                    sshEveryOther = not sshEveryOther
                    universalTestingBiLabels.append(0)
                    universalTestingMuLabels.append(badActorLabels.index('safe'))
                    testingTotalLeft -= 1
                elif 'sshd[' in line and not sshEveryOther:
                    sshEveryOther = not sshEveryOther
                else:
                    universalTestingSet.append(line)
                    universalTestingBiLabels.append(0)
                    universalTestingMuLabels.append(badActorLabels.index('safe'))
                    testingTotalLeft -= 1
    ###################################################################################################################################################

    trainingLogs = np.array(universalTrainingSet)
    trainingBiLabels = np.array(universalTrainingBiLabels)
    trainingMuLabels = np.array(universalTrainingMuLabels)

    randomize = np.arange(len(trainingLogs))
    np.random.shuffle(randomize)

    trainingLogs = trainingLogs[randomize]
    trainingBiLabels = list(trainingBiLabels[randomize])
    trainingMuLabels = list(trainingMuLabels[randomize])

    for i in range(len(trainingBiLabels)):
        trainingBiLabels[i] = trainingBiLabels[i].item()
        trainingMuLabels[i] = trainingMuLabels[i].item()
    
    with open('universalTrainingSet.txt', 'w', encoding='utf8') as trainingSetFile:
        with open('universalTrainingSet_biLabels.txt', 'w', encoding='utf8') as biLabelFile:
            with open('universalTrainingSet_muLabels.txt', 'w', encoding='utf8') as muLabelFile:
                for line in trainingLogs:
                    trainingSetFile.write(line)
                json.dump(trainingBiLabels, biLabelFile)
                json.dump(trainingMuLabels, muLabelFile)
    
    ###################################################################################################################################################

    testingLogs = np.array(universalTestingSet)
    testingBiLabels = np.array(universalTestingBiLabels)
    testingMuLabels = np.array(universalTestingMuLabels)

    randomize = np.arange(len(testingLogs))
    np.random.shuffle(randomize)

    testingLogs = testingLogs[randomize]
    testingBiLabels = list(testingBiLabels[randomize])
    testingMuLabels = list(testingMuLabels[randomize])

    for i in range(len(testingBiLabels)):
        testingBiLabels[i] = testingBiLabels[i].item()
        testingMuLabels[i] = testingMuLabels[i].item()

    with open('universalTestingSet.txt', 'w', encoding='utf8') as testingSetFile:
        with open('universalTestingSet_biLabels.txt', 'w', encoding='utf8') as biLabelFile:
            with open('universalTestingSet_muLabels.txt', 'w', encoding='utf8') as muLabelFile:
                for line in testingLogs:
                    testingSetFile.write(line)
                json.dump(testingBiLabels, biLabelFile)
                json.dump(testingMuLabels, muLabelFile)

    ###################################################################################################################################################

    info += ('\nUniversal Training & Testing Sets w/ Labels have been created.'
    + '\n\nUniversal Training Set Actual Size: {}\nUniversal Testing Set Actual Size: {}'.format(trainingLogs.size, testingLogs.size)
    ) 

    tk.messagebox.showinfo(title='Stats', message=info)

#print('\nLog file is sorted, and universal training set is created.')
Button()
